created: 20220916031356122
creator: miao
modified: 20230827101624952
modifier: WhiteFall
tags: 编程语言的特性与概念
title: C# 的特性和概念
type: text/vnd.tiddlywiki

!! 元数据

<<<
元数据（metadata）就是查找、描述数据的数据。

https://www.cnblogs.com/tuqunfu/p/15920745.html
<<<

# 元数据的分类（eg:一张由kent拍摄的大小为20K的JPG格式的印着一只小狗的圣诞卡照片这个数据为例）

# 固有性元数据：与事物构成有关的元数据（20K、JPG）
# 管理性元数据：与事物处理方式有关的元数据 （kent拍摄、圣诞卡）
# 描述性元数据：与事物本质有关的元数据（狗、小狗、圣诞、照片、圣诞节）

* 意义，元数据是所有组织系统的基础，构造信息检索系统类比于索引和目录，提供产品的可查找性服务，系统依赖于元数据

* 元数据在程序领域表现形式是一种二进制信息，用以对存储在公共语言运行库（CLR）可移动执行文件（PE）或者存储在内存中程序进行描述，编译器將代码编译成PE文件时便会將元数据插入到该文件的一部分，而将代码转换为 Microsoft 中间语言 (MSIL) 并将其插入到该文件的另一部分中，所以包含元数据和代码生成（中间语言IL）的部分。''元数据將存储如下信息，程序集（名称、版本、区域性、公钥）、类的说明（名称、可见性、基类和实现的接口）、类的成员（方法、字段、属性、事件、嵌套的类型）等。当执行代码的时候，运行库將元数据加载到内存中，并通过引用它（元数据）来发现有关代码的类、成员、继承等信息。''
* ''元数据的意义在于元数据是描述信息资源或数据等对象的数据''，其使用目的在于：识别资源、评价资源、追踪资源在使用过程中的变化；实现简单高效地管理大量网络化数据；实现信息资源的有效发现、查找、一体化组织和对使用资源的有效管理；元数据一经建立，便可以共享数据信息；元数据首先是一种编码体系，具体元数据应该包含什么内容根据场景来定义，但是其要实现功能无非就是描述功能、整合功能、控制功能和代理功能，方便去获取或者使用元数据描述的数据内容。



!! C# 特性（Attribute）与反射（Reflection）

<<<
区分特性(Attribute)和属性(Property).属性就是面向对象思想里所说的封装在类里面的数据字段.
<<<

''特性（Attribute）''用于添加元数据（为代码添加的额外信息），如编译器指令和注释、描述、方法、类等其他信息。我们通常是将特性标记到方法，类或者上，在使用的这些结构的时候，通过反射(reflection)这一非常高级的技术，获取它们通过特性标记的信息，从而进行某些特殊的处理。dotNet 框架提供了两种类型的特性：预定义特性和自定义特性。

通常，特性会放在类、字段、方法等定义的上面，用来指定特定的内容。特性在编译时会嵌入到程序集中，我们可以使用反射来获得相应的特性值。''特性本身也是一个类''。所以__特性也可以用特性来指定和修饰__。

创建并使用自定义特性包含四个步骤：

# 声明自定义特性
# 构建自定义特性
# 在目标程序元素上应用自定义特性
# 通过反射访问特性

最后一个步骤包含编写一个简单的程序来读取元数据以便查找各种符号。元数据是用于描述其他数据的数据和信息。该程序应使用反射来在运行时访问特性。

系统也给我们提供了一些特性，比如Serializable 标记一个可序列化的类，DebuggerStepThrough设置方法在调试时为跳过的状态。

''反射（Reflection）''最主要的作用，是用来收集对象的数据（元数据），而不是对象本身的数据。这些数据包括对象的类型，以及关于对象成员（包括方法、特性、构造函数）的信息，和关于特定程序集的信息。此外，还包括存储在元素特性中的任何信息。

可以使用反射来创建对象的实例，只要有了对象的类型。同时，使用反射创建泛型对象是可能的，但比较复杂，需要泛型对象的类型以及所有泛型参数的类型。


!! C# 委托（Delegate）与事件（Event）
类或者对象可以通过事件向其它类或者对象通知发生相关的事情。所有的委托（Delegate）都派生自 System.Delegate 类，即委托是一个类数据类型而非方法。发送（或引发）事件的类称为“Sender发送者”，接收（或处理）事件的类称为“Handler处理者”。

''委托（Delegate）''本质上就是函数指针，可以将其当作一般的形参在另一个函数中传递，并在该函数体内调用。委托（delegate）多用在 1.回调触发事件 2.form/page/object间调用 这是最佳实践。


''事件（Event）''是一种专门的代表类型，主要用于消息或通知传递。事件只能从它们发布的类型调用，通常基于EventHandler委托，其中对象代表事件的发送方，System.EventArgs派生类保存有关事件的数据。实现事件和回调方法都是基于委托（delegate）。

声明事件需要先声明该事件的委托型类，通过声明的委托类型和event关键字来声明事件。

```cs
public delegate void ClickEventHandler(string args);
// 基于上面的委托定义事件
public event ClickEventHandler ClickEvent;
```

以上代码简单实现了事件ClickEvent的定义，该事件在声明的时会调用委托。



!! C# 索引器（Indexer）
索引器（英文名：Indexer）是类中的一个特殊成员，它能够让对象以类似数组的形式来操作，使程序看起来更为直观，更容易编写。索引器与属性类似，在定义索引器时同样会用到 get 和 set 访问器，不同的是，访问属性不需要提供参数而访问索引器则需要提供相应的参数。

通常情况下，属性只能访问单一的字段（一个属性对一个字段进行封装），如果想访问多个数据成员，就需要使用索引器。索引器是类的特殊成员，它可以根据索引在多个成员中进行选择，能够让对象以类似数组的方式来存取。索引器的数据类型必须是统一的。


<<<
访问修饰符作用：设定访问权限，限制类中的成员（属性、方法等）可访问的范围，访问范围通常有，类的内部、类的外部。

字段又称为：“成员变量”就是类中的变量，一般在类的内部做数据交互使用。

属性其实就是外界访问私有字段的入口，本质通过get和set方法来操作对应的字段。属性本身不保存任何数据。
属性的作用：A.避免出现非法数据，例如一个年龄属性，正常逻辑是年龄是不可以出现负数的，如果用户对年龄进行了负数的赋值，我们通过属性的set方法加入判断逻辑，从而排除这种非法数据。B.限定属性只读或者只写，例如有些属性为了保护数据，我们只能读取，而不能赋值。具体使用的话，我们根据需要，屏蔽set或get方法达到只读和只写。

访问器：在属性中的只实现get访问器的，称只读属性；只实现set访问器的，称只写属性；两者都实现的，称读写属性。（参见后面的示例）。通过访问器，我们可以根据访问者的身份对其操作权限进行限定，并对数据的合法性进行检查。

私有的字段m_name可以通过公开的属性Name对它进行读写操作。 通过“属性”读取“字段”值时，将触发get访问器；通过“属性”为“字段”赋值，将触发set访问器。
<<<

```Csharp
element-type this[int index]
{
   // get 访问器
   get
   {
      // 返回 index 指定的值
   }

   // set 访问器
   set
   {
      // 设置 index 指定的值
   }
}
```

索引器的行为的声明在某种程度上类似于属性（property）。就像属性（property），您可使用 get 和 set 访问器来定义索引器。但是，属性返回或设置一个特定的数据成员（某个成员变量），而索引器返回或设置对象实例的一个特定值。


!! 递归算法

递归是一种算法 它是直接或间接的调用自己。

递归其实就是 处理整个事情 = 处理一部分 + 按照相同的处理方法处理剩余的部分！

这里的处理整件事情 ====> 就是 DFS(all)
处理一部分就是 ========> 业务代码(具体处理部分的代码)
按照相同的办法处理剩余的部分 =======> 就是 DFS(others)

比如：
DFS(10 ) = xxx + DFS(9)

总共要处理十个单位的东西 DFS（10）
我已经处理了一部分 xxxx
剩下的一部分就是 DFS（9）

前后事件顺序相关逻辑相同

总的状态 = 当前处理的事情 + 剩余的状态
比如： dfs(5) = xxxx + dfs(4)


递归函数就是在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。

举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * ... * n，用函数 fact(n)表示，可以看出：

fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n

所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。

于是，fact(n)用递归的方式写出来就是：

def fact(n): if n==1: return 1 return n * fact(n - 1)

函数内部的代码是相同的，只是针对参数不同，处理的结果不同。当参数满足一个条件时，函数不再执行，通常被称为递归的出口，否则会出现死循环。

例如：

def sum_numbers(num):     print(num)     #递归的出口很重要，否则会出现死循环     if num==1:       return    sum_numbers(num-1) sum_numbers(3)

# 回溯：一层层的调用直至满足终止条件的过程称为回溯。
# 递推：从满足终止条件向外层逐层返回的过程称为递推。

1、什么时候用递归条件
一个问题的解可以分解为几个子问题的解；
这个问题与分解之后的子问题求解思路完全一致；
一定有一个终止条件。
2、用递归写一个斐波那契数列


!! 匿名方法

由于匿名方法没有方法签名，只有方法体，所以无法使用命名方法类似的 方法名(); 去调用，所以只能将由委托变量去调用它，换言之，匿名方法将自己唯一拥有的方法主体交给委托，让委托代理执行。

```cs
delegate void NumberChanger(int n);
...
NumberChanger nc = delegate(int x)
{
    Console.WriteLine("Anonymous Method: {0}", x);
};
```

代码块 `Console.WriteLine("Anonymous Method: {0}", x); `是匿名方法的主体。


!! 集合（Collection）

集合（Collection）类是专门用于数据存储和检索的类。

这些类提供了堆栈（stack）、队列（queue）、列表（list）和哈希表（hash table）动态数组（ArrayList）排序列表（SortedList）点阵列（BitArray）字典的用法的支持。

字典,堆栈，队列不能排序，如果想对字典排序就要用其它方法或集合，如SortedDictionary<TKey,TValue>。


!! 可空类型（可以为空）
